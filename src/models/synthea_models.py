"""Synthea Data Models

Simple dataclass models representing the exact structure of Synthea CSV files.
These models correspond to the FHIR-based synthetic patient data generated by Synthea.
"""

from __future__ import annotations

import attr
from dataclasses import dataclass, field
from typing import Optional, List
from dateutil.parser import parse as parse_date
from dateutil.parser import ParserError
from .base_record import BaseRecord


@attr.s(auto_attribs=True)
class Allergy(BaseRecord):
    """Allergy model corresponding to allergies.csv using attrs for consistency."""
    START: str = attr.ib(validator=attr.validators.instance_of(str))
    PATIENT: str = attr.ib(validator=attr.validators.instance_of(str))
    ENCOUNTER: str = attr.ib(validator=attr.validators.instance_of(str))
    CODE: str = attr.ib(validator=attr.validators.instance_of(str))
    DESCRIPTION: str = attr.ib(validator=attr.validators.instance_of(str))
    STOP: Optional[str] = attr.ib(default=None, validator=attr.validators.optional(attr.validators.instance_of(str)))
    
    @property
    def record_id(self) -> str:
        return f"{self.PATIENT}_{self.CODE}"
    
    @property
    def timestamp(self) -> float:
        """Convert START date to timestamp using dateutil for robust parsing."""
        try:
            parsed_date = parse_date(self.START)
            return parsed_date.timestamp()
        except (ParserError, ValueError, AttributeError):
            return 0.0  # Fallback for invalid dates


@attr.s(auto_attribs=True)
class CarePlan(BaseRecord):
    """Care Plan model corresponding to careplans.csv using attrs for consistency."""
    Id: str = attr.ib(validator=attr.validators.instance_of(str))
    START: str = attr.ib(validator=attr.validators.instance_of(str))
    PATIENT: str = attr.ib(validator=attr.validators.instance_of(str))
    ENCOUNTER: str = attr.ib(validator=attr.validators.instance_of(str))
    CODE: str = attr.ib(validator=attr.validators.instance_of(str))
    DESCRIPTION: str = attr.ib(validator=attr.validators.instance_of(str))
    STOP: Optional[str] = attr.ib(default=None, validator=attr.validators.optional(attr.validators.instance_of(str)))
    REASONCODE: Optional[str] = attr.ib(default=None, validator=attr.validators.optional(attr.validators.instance_of(str)))
    REASONDESCRIPTION: Optional[str] = attr.ib(default=None, validator=attr.validators.optional(attr.validators.instance_of(str)))
    
    @property
    def record_id(self) -> str:
        return self.Id
    
    @property
    def timestamp(self) -> float:
        """Convert date to timestamp using dateutil for robust parsing."""
        try:
            # Try to parse the START date field if available
            date_field = getattr(self, 'START', None) or getattr(self, 'DATE', None) or getattr(self, 'BIRTHDATE', None)
            if date_field:
                parsed_date = parse_date(date_field)
                return parsed_date.timestamp()
            return 0.0
        except (ParserError, ValueError, AttributeError):
            return 0.0  # Fallback for invalid dates


@attr.s(auto_attribs=True)
class Condition(BaseRecord):
    """Condition model corresponding to conditions.csv using attrs for consistency."""
    START: str = attr.ib(validator=attr.validators.instance_of(str))
    PATIENT: str = attr.ib(validator=attr.validators.instance_of(str))
    ENCOUNTER: str = attr.ib(validator=attr.validators.instance_of(str))
    CODE: str = attr.ib(validator=attr.validators.instance_of(str))
    DESCRIPTION: str = attr.ib(validator=attr.validators.instance_of(str))
    STOP: Optional[str] = attr.ib(default=None, validator=attr.validators.optional(attr.validators.instance_of(str)))
    
    @property
    def record_id(self) -> str:
        return f"{self.PATIENT}_{self.CODE}_{self.START}"
    
    @property
    def timestamp(self) -> float:
        """Convert date to timestamp using dateutil for robust parsing."""
        try:
            # Try to parse the START date field if available
            date_field = getattr(self, 'START', None) or getattr(self, 'DATE', None) or getattr(self, 'BIRTHDATE', None)
            if date_field:
                parsed_date = parse_date(date_field)
                return parsed_date.timestamp()
            return 0.0
        except (ParserError, ValueError, AttributeError):
            return 0.0  # Fallback for invalid dates


@dataclass
class Encounter(BaseRecord):
    """Encounter model corresponding to encounters.csv"""
    Id: str
    START: str
    STOP: Optional[str]
    PATIENT: str
    PROVIDER: str
    PAYER: str
    ENCOUNTERCLASS: str
    CODE: str
    DESCRIPTION: str
    BASE_ENCOUNTER_COST: float
    TOTAL_CLAIM_COST: float
    PAYER_COVERAGE: float
    REASONCODE: Optional[str]
    REASONDESCRIPTION: Optional[str]
    
    # Related data grouped by encounter
    allergies: List[Allergy] = field(default_factory=list)
    careplans: List[CarePlan] = field(default_factory=list)
    conditions: List[Condition] = field(default_factory=list)
    imaging_studies: List[ImagingStudy] = field(default_factory=list)
    immunizations: List[Immunization] = field(default_factory=list)
    medications: List[Medication] = field(default_factory=list)
    observations: List[Observation] = field(default_factory=list)
    procedures: List[Procedure] = field(default_factory=list)
    
    @property
    def record_id(self) -> str:
        return self.Id
    
    @property
    def timestamp(self) -> float:
        return 0.0  # Placeholder - would need proper date parsing


@dataclass
class ImagingStudy(BaseRecord):
    """Imaging Study model corresponding to imaging_studies.csv"""
    Id: str
    DATE: str
    PATIENT: str
    ENCOUNTER: str
    BODYSITE_CODE: str
    BODYSITE_DESCRIPTION: str
    MODALITY_CODE: str
    MODALITY_DESCRIPTION: str
    SOP_CODE: str
    SOP_DESCRIPTION: str
    
    @property
    def record_id(self) -> str:
        return self.Id
    
    @property
    def timestamp(self) -> float:
        return 0.0  # Placeholder - would need proper date parsing


@dataclass
class Immunization(BaseRecord):
    """Immunization model corresponding to immunizations.csv"""
    DATE: str
    PATIENT: str
    ENCOUNTER: str
    CODE: str
    DESCRIPTION: str
    BASE_COST: float
    
    @property
    def record_id(self) -> str:
        return f"{self.PATIENT}_{self.CODE}_{self.DATE}"
    
    @property
    def timestamp(self) -> float:
        return 0.0  # Placeholder - would need proper date parsing


@dataclass
class Medication(BaseRecord):
    """Medication model corresponding to medications.csv"""
    START: str
    STOP: Optional[str]
    PATIENT: str
    PAYER: str
    ENCOUNTER: str
    CODE: str
    DESCRIPTION: str
    BASE_COST: float
    PAYER_COVERAGE: float
    DISPENSES: int
    TOTALCOST: float
    REASONCODE: Optional[str]
    REASONDESCRIPTION: Optional[str]
    
    @property
    def record_id(self) -> str:
        return f"{self.PATIENT}_{self.CODE}_{self.START}"
    
    @property
    def timestamp(self) -> float:
        return 0.0  # Placeholder - would need proper date parsing


@dataclass
class Observation(BaseRecord):
    """Observation model corresponding to observations.csv"""
    DATE: str
    PATIENT: str
    ENCOUNTER: str
    CODE: str
    DESCRIPTION: str
    VALUE: Optional[str]
    UNITS: Optional[str]
    TYPE: str
    
    @property
    def record_id(self) -> str:
        return f"{self.PATIENT}_{self.CODE}_{self.DATE}"
    
    @property
    def timestamp(self) -> float:
        return 0.0  # Placeholder - would need proper date parsing


@dataclass
class Organization(BaseRecord):
    """Organization model corresponding to organizations.csv"""
    Id: str
    NAME: str
    ADDRESS: str
    CITY: str
    STATE: str
    ZIP: str
    LAT: float
    LON: float
    PHONE: Optional[str]
    REVENUE: float
    UTILIZATION: int
    
    @property
    def record_id(self) -> str:
        return self.Id
    
    @property
    def timestamp(self) -> float:
        return 0.0  # Placeholder


@attr.s(auto_attribs=True)
class Patient(BaseRecord):
    """Patient model corresponding to patients.csv using attrs for consistency."""
    
    # Mandatory fields first
    Id: str = attr.ib(validator=attr.validators.instance_of(str))
    BIRTHDATE: str = attr.ib(validator=attr.validators.instance_of(str))
    SSN: str = attr.ib(validator=attr.validators.instance_of(str))
    FIRST: str = attr.ib(validator=attr.validators.instance_of(str))
    LAST: str = attr.ib(validator=attr.validators.instance_of(str))
    RACE: str = attr.ib(validator=attr.validators.instance_of(str))
    ETHNICITY: str = attr.ib(validator=attr.validators.instance_of(str))
    GENDER: str = attr.ib(validator=attr.validators.instance_of(str))
    BIRTHPLACE: str = attr.ib(validator=attr.validators.instance_of(str))
    ADDRESS: str = attr.ib(validator=attr.validators.instance_of(str))
    CITY: str = attr.ib(validator=attr.validators.instance_of(str))
    STATE: str = attr.ib(validator=attr.validators.instance_of(str))
    COUNTY: str = attr.ib(validator=attr.validators.instance_of(str))
    ZIP: str = attr.ib(validator=attr.validators.instance_of(str))
    LAT: float = attr.ib(validator=attr.validators.instance_of((int, float)))
    LON: float = attr.ib(validator=attr.validators.instance_of((int, float)))
    HEALTHCARE_EXPENSES: float = attr.ib(validator=attr.validators.instance_of((int, float)))
    HEALTHCARE_COVERAGE: float = attr.ib(validator=attr.validators.instance_of((int, float)))
    
    # Optional fields after mandatory ones
    DEATHDATE: Optional[str] = attr.ib(default=None, validator=attr.validators.optional(attr.validators.instance_of(str)))
    DRIVERS: Optional[str] = attr.ib(default=None, validator=attr.validators.optional(attr.validators.instance_of(str)))
    PASSPORT: Optional[str] = attr.ib(default=None, validator=attr.validators.optional(attr.validators.instance_of(str)))
    PREFIX: Optional[str] = attr.ib(default=None, validator=attr.validators.optional(attr.validators.instance_of(str)))
    SUFFIX: Optional[str] = attr.ib(default=None, validator=attr.validators.optional(attr.validators.instance_of(str)))
    MAIDEN: Optional[str] = attr.ib(default=None, validator=attr.validators.optional(attr.validators.instance_of(str)))
    MARITAL: Optional[str] = attr.ib(default=None, validator=attr.validators.optional(attr.validators.instance_of(str)))
    
    # Related data
    payer_transitions: List['PayerTransition'] = attr.ib(factory=list, validator=attr.validators.instance_of(list))
    encounters: List['Encounter'] = attr.ib(factory=list, validator=attr.validators.instance_of(list))
    
    # NHS Metrics tracking fields
    arrival_time: float = attr.ib(default=0.0, validator=attr.validators.instance_of((int, float)))
    departure_time: float = attr.ib(default=0.0, validator=attr.validators.instance_of((int, float)))
    initial_assessment_time: float = attr.ib(default=0.0, validator=attr.validators.instance_of((int, float)))
    treatment_start_time: float = attr.ib(default=0.0, validator=attr.validators.instance_of((int, float)))
    triage_category: str = attr.ib(default="", validator=attr.validators.instance_of(str))
    triage_priority: int = attr.ib(default=0, validator=attr.validators.instance_of(int))
    is_reattendance: bool = attr.ib(default=False, validator=attr.validators.instance_of(bool))
    admitted: bool = attr.ib(default=False, validator=attr.validators.instance_of(bool))
    disposal: str = attr.ib(default="", validator=attr.validators.instance_of(str))
    presenting_complaint: str = attr.ib(default="", validator=attr.validators.instance_of(str))
    left_without_being_seen: bool = attr.ib(default=False, validator=attr.validators.instance_of(bool))
    age: int = attr.ib(default=0, validator=attr.validators.instance_of(int))
    gender: str = attr.ib(default="", validator=attr.validators.instance_of(str))
    _timestamp: float = attr.ib(default=0.0, validator=attr.validators.instance_of((int, float)))
    
    # Centralized calculation methods to eliminate duplicate computations
    def get_total_journey_time(self) -> float:
        """Calculate total time in A&E (departure - arrival).
        
        Returns:
            Total journey time in minutes
        """
        return self.departure_time - self.arrival_time
    
    def get_time_to_initial_assessment(self) -> float:
        """Calculate time from arrival to initial assessment (triage).
        
        Returns:
            Time to initial assessment in minutes, 0 if not assessed
        """
        return self.initial_assessment_time - self.arrival_time if self.initial_assessment_time > 0 else 0.0
    
    def get_time_to_treatment(self) -> float:
        """Calculate time from arrival to treatment start (doctor consultation).
        
        Returns:
            Time to treatment in minutes, 0 if no treatment started
        """
        return self.treatment_start_time - self.arrival_time if self.treatment_start_time > 0 else 0.0
    
    def meets_4hour_standard(self) -> bool:
        """Check if patient meets NHS 4-hour standard (240 minutes).
        
        Returns:
            True if total journey time <= 240 minutes
        """
        return self.get_total_journey_time() <= 240.0
    
    def is_completed_journey(self) -> bool:
        """Check if patient has completed their journey (has departure time).
        
        Returns:
            True if patient has departed
        """
        return self.departure_time > 0.0
    
    def extract_symptoms_from_observations(self) -> dict:
        """Extract symptoms from patient observations using efficient pattern matching.
        
        Returns:
            Dictionary of symptoms extracted from observations
        """
        # Symptom mapping for efficient extraction
        symptom_patterns = {
            'pain': ['pain'],
            'fever': ['fever', 'temperature'],
            'nausea': ['nausea'],
            'vomiting': ['vomit'],
            'breathing_difficulty': ['breath', 'respiratory'],
            'chest_pain': ['chest'],
            'headache': ['head'],
            'severe_symptoms': ['emergency', 'urgent']
        }
        
        # Extract from observations and encounters using attrs fields directly
        descriptions = []
        if self.encounters:
            descriptions.extend(enc.DESCRIPTION.lower() for enc in self.encounters)
        # Note: observations field would need to be added to Patient attrs model if needed
        
        # Efficient symptom detection using any() and generator expressions
        return {
            symptom: any(pattern in desc for desc in descriptions for pattern in patterns)
            for symptom, patterns in symptom_patterns.items()
            if any(pattern in desc for desc in descriptions for pattern in patterns)
        }
    
    @property
    def record_id(self) -> str:
        return self.Id
    
    @property
    def timestamp(self) -> float:
        return self._timestamp
    
    @timestamp.setter
    def timestamp(self, value: float) -> None:
        self._timestamp = value


@dataclass
class PayerTransition(BaseRecord):
    """Payer Transition model corresponding to payer_transitions.csv"""
    PATIENT: str
    START_YEAR: int
    END_YEAR: Optional[int]
    PAYER: str
    OWNERSHIP: str
    
    @property
    def record_id(self) -> str:
        return f"{self.PATIENT}_{self.START_YEAR}"
    
    @property
    def timestamp(self) -> float:
        return float(self.START_YEAR)


@dataclass
class Payer(BaseRecord):
    """Payer model corresponding to payers.csv"""
    Id: str
    NAME: str
    ADDRESS: Optional[str]
    CITY: Optional[str]
    STATE_HEADQUARTERED: Optional[str]
    ZIP: Optional[str]
    PHONE: Optional[str]
    AMOUNT_COVERED: float
    AMOUNT_UNCOVERED: float
    REVENUE: float
    COVERED_ENCOUNTERS: int
    UNCOVERED_ENCOUNTERS: int
    COVERED_MEDICATIONS: int
    UNCOVERED_MEDICATIONS: int
    COVERED_PROCEDURES: int
    UNCOVERED_PROCEDURES: int
    COVERED_IMMUNIZATIONS: int
    UNCOVERED_IMMUNIZATIONS: int
    UNIQUE_CUSTOMERS: int
    QOLS_AVG: float
    MEMBER_MONTHS: int
    
    @property
    def record_id(self) -> str:
        return self.Id
    
    @property
    def timestamp(self) -> float:
        return 0.0  # Placeholder


@dataclass
class Procedure(BaseRecord):
    """Procedure model corresponding to procedures.csv"""
    DATE: str
    PATIENT: str
    ENCOUNTER: str
    CODE: str
    DESCRIPTION: str
    BASE_COST: float
    REASONCODE: Optional[str]
    REASONDESCRIPTION: Optional[str]
    
    @property
    def record_id(self) -> str:
        return f"{self.PATIENT}_{self.CODE}_{self.DATE}"
    
    @property
    def timestamp(self) -> float:
        return 0.0  # Placeholder - would need proper date parsing


@dataclass
class Provider(BaseRecord):
    """Provider model corresponding to providers.csv"""
    Id: str
    ORGANIZATION: str
    NAME: str
    GENDER: str
    SPECIALITY: str
    ADDRESS: str
    CITY: str
    STATE: str
    ZIP: str
    LAT: float
    LON: float
    UTILIZATION: int
    
    @property
    def record_id(self) -> str:
        return self.Id
    
    @property
    def timestamp(self) -> float:
        return 0.0  # Placeholder


# Export all models
__all__ = [
    'Allergy',
    'CarePlan', 
    'Condition',
    'Encounter',
    'ImagingStudy',
    'Immunization',
    'Medication',
    'Observation',
    'Organization',
    'Patient',
    'PayerTransition',
    'Payer',
    'Procedure',
    'Provider'
]