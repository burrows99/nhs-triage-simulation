"""Synthea Data Models

Simple dataclass models representing the exact structure of Synthea CSV files.
These models correspond to the FHIR-based synthetic patient data generated by Synthea.
"""

from __future__ import annotations

from dataclasses import dataclass, field
from typing import Optional, List
from .base_record import BaseRecord


@dataclass
class Allergy(BaseRecord):
    """Allergy model corresponding to allergies.csv"""
    START: str
    STOP: Optional[str]
    PATIENT: str
    ENCOUNTER: str
    CODE: str
    DESCRIPTION: str
    
    @property
    def record_id(self) -> str:
        return f"{self.PATIENT}_{self.CODE}"
    
    @property
    def timestamp(self) -> float:
        # Convert date string to timestamp if needed
        return 0.0  # Placeholder - would need proper date parsing


@dataclass
class CarePlan(BaseRecord):
    """Care Plan model corresponding to careplans.csv"""
    Id: str
    START: str
    STOP: Optional[str]
    PATIENT: str
    ENCOUNTER: str
    CODE: str
    DESCRIPTION: str
    REASONCODE: Optional[str]
    REASONDESCRIPTION: Optional[str]
    
    @property
    def record_id(self) -> str:
        return self.Id
    
    @property
    def timestamp(self) -> float:
        return 0.0  # Placeholder - would need proper date parsing


@dataclass
class Condition(BaseRecord):
    """Condition model corresponding to conditions.csv"""
    START: str
    STOP: Optional[str]
    PATIENT: str
    ENCOUNTER: str
    CODE: str
    DESCRIPTION: str
    
    @property
    def record_id(self) -> str:
        return f"{self.PATIENT}_{self.CODE}_{self.START}"
    
    @property
    def timestamp(self) -> float:
        return 0.0  # Placeholder - would need proper date parsing


@dataclass
class Encounter(BaseRecord):
    """Encounter model corresponding to encounters.csv"""
    Id: str
    START: str
    STOP: Optional[str]
    PATIENT: str
    PROVIDER: str
    PAYER: str
    ENCOUNTERCLASS: str
    CODE: str
    DESCRIPTION: str
    BASE_ENCOUNTER_COST: float
    TOTAL_CLAIM_COST: float
    PAYER_COVERAGE: float
    REASONCODE: Optional[str]
    REASONDESCRIPTION: Optional[str]
    
    # Related data grouped by encounter
    allergies: List[Allergy] = field(default_factory=list)
    careplans: List[CarePlan] = field(default_factory=list)
    conditions: List[Condition] = field(default_factory=list)
    imaging_studies: List[ImagingStudy] = field(default_factory=list)
    immunizations: List[Immunization] = field(default_factory=list)
    medications: List[Medication] = field(default_factory=list)
    observations: List[Observation] = field(default_factory=list)
    procedures: List[Procedure] = field(default_factory=list)
    
    @property
    def record_id(self) -> str:
        return self.Id
    
    @property
    def timestamp(self) -> float:
        return 0.0  # Placeholder - would need proper date parsing


@dataclass
class ImagingStudy(BaseRecord):
    """Imaging Study model corresponding to imaging_studies.csv"""
    Id: str
    DATE: str
    PATIENT: str
    ENCOUNTER: str
    BODYSITE_CODE: str
    BODYSITE_DESCRIPTION: str
    MODALITY_CODE: str
    MODALITY_DESCRIPTION: str
    SOP_CODE: str
    SOP_DESCRIPTION: str
    
    @property
    def record_id(self) -> str:
        return self.Id
    
    @property
    def timestamp(self) -> float:
        return 0.0  # Placeholder - would need proper date parsing


@dataclass
class Immunization(BaseRecord):
    """Immunization model corresponding to immunizations.csv"""
    DATE: str
    PATIENT: str
    ENCOUNTER: str
    CODE: str
    DESCRIPTION: str
    BASE_COST: float
    
    @property
    def record_id(self) -> str:
        return f"{self.PATIENT}_{self.CODE}_{self.DATE}"
    
    @property
    def timestamp(self) -> float:
        return 0.0  # Placeholder - would need proper date parsing


@dataclass
class Medication(BaseRecord):
    """Medication model corresponding to medications.csv"""
    START: str
    STOP: Optional[str]
    PATIENT: str
    PAYER: str
    ENCOUNTER: str
    CODE: str
    DESCRIPTION: str
    BASE_COST: float
    PAYER_COVERAGE: float
    DISPENSES: int
    TOTALCOST: float
    REASONCODE: Optional[str]
    REASONDESCRIPTION: Optional[str]
    
    @property
    def record_id(self) -> str:
        return f"{self.PATIENT}_{self.CODE}_{self.START}"
    
    @property
    def timestamp(self) -> float:
        return 0.0  # Placeholder - would need proper date parsing


@dataclass
class Observation(BaseRecord):
    """Observation model corresponding to observations.csv"""
    DATE: str
    PATIENT: str
    ENCOUNTER: str
    CODE: str
    DESCRIPTION: str
    VALUE: Optional[str]
    UNITS: Optional[str]
    TYPE: str
    
    @property
    def record_id(self) -> str:
        return f"{self.PATIENT}_{self.CODE}_{self.DATE}"
    
    @property
    def timestamp(self) -> float:
        return 0.0  # Placeholder - would need proper date parsing


@dataclass
class Organization(BaseRecord):
    """Organization model corresponding to organizations.csv"""
    Id: str
    NAME: str
    ADDRESS: str
    CITY: str
    STATE: str
    ZIP: str
    LAT: float
    LON: float
    PHONE: Optional[str]
    REVENUE: float
    UTILIZATION: int
    
    @property
    def record_id(self) -> str:
        return self.Id
    
    @property
    def timestamp(self) -> float:
        return 0.0  # Placeholder


@dataclass
class Patient(BaseRecord):
    """Patient model corresponding to patients.csv"""
    Id: str
    BIRTHDATE: str
    DEATHDATE: Optional[str]
    SSN: str
    DRIVERS: Optional[str]
    PASSPORT: Optional[str]
    PREFIX: Optional[str]
    FIRST: str
    LAST: str
    SUFFIX: Optional[str]
    MAIDEN: Optional[str]
    MARITAL: Optional[str]
    RACE: str
    ETHNICITY: str
    GENDER: str
    BIRTHPLACE: str
    ADDRESS: str
    CITY: str
    STATE: str
    COUNTY: str
    ZIP: str
    LAT: float
    LON: float
    HEALTHCARE_EXPENSES: float
    HEALTHCARE_COVERAGE: float
    
    # Related data
    payer_transitions: List[PayerTransition] = field(default_factory=list)
    encounters: List[Encounter] = field(default_factory=list)
    
    # NHS Metrics tracking fields
    arrival_time: float = 0.0
    departure_time: float = 0.0
    initial_assessment_start: float = 0.0
    treatment_start: float = 0.0
    triage_category: str = ""
    triage_priority: int = 0
    is_reattendance: bool = False
    admitted: bool = False
    disposal: str = ""
    presenting_complaint: str = ""
    left_without_being_seen: bool = False
    age: int = 0
    gender: str = ""
    _timestamp: float = 0.0  # Private field for timestamp storage
    
    def extract_symptoms_from_observations(self) -> dict:
        """Extract symptoms from patient observations for triage.
        
        Returns:
            Dictionary of symptoms extracted from observations
        """
        symptoms = {}
        
        # Extract symptoms from observations if available
        if hasattr(self, 'observations') and self.observations:
            for obs in self.observations:
                # Map observation descriptions to symptom keys
                if 'pain' in obs.DESCRIPTION.lower():
                    symptoms['pain'] = True
                if 'fever' in obs.DESCRIPTION.lower() or 'temperature' in obs.DESCRIPTION.lower():
                    symptoms['fever'] = True
                if 'nausea' in obs.DESCRIPTION.lower():
                    symptoms['nausea'] = True
                if 'vomit' in obs.DESCRIPTION.lower():
                    symptoms['vomiting'] = True
                if 'breath' in obs.DESCRIPTION.lower() or 'respiratory' in obs.DESCRIPTION.lower():
                    symptoms['breathing_difficulty'] = True
                if 'chest' in obs.DESCRIPTION.lower():
                    symptoms['chest_pain'] = True
                if 'head' in obs.DESCRIPTION.lower():
                    symptoms['headache'] = True
        
        # If no observations available, extract from encounters
        if not symptoms and self.encounters:
            for encounter in self.encounters:
                desc = encounter.DESCRIPTION.lower()
                if 'pain' in desc:
                    symptoms['pain'] = True
                if 'fever' in desc:
                    symptoms['fever'] = True
                if 'emergency' in desc or 'urgent' in desc:
                    symptoms['severe_symptoms'] = True
        
        return symptoms
    
    @property
    def record_id(self) -> str:
        return self.Id
    
    @property
    def timestamp(self) -> float:
        return self._timestamp
    
    @timestamp.setter
    def timestamp(self, value: float) -> None:
        self._timestamp = value


@dataclass
class PayerTransition(BaseRecord):
    """Payer Transition model corresponding to payer_transitions.csv"""
    PATIENT: str
    START_YEAR: int
    END_YEAR: Optional[int]
    PAYER: str
    OWNERSHIP: str
    
    @property
    def record_id(self) -> str:
        return f"{self.PATIENT}_{self.START_YEAR}"
    
    @property
    def timestamp(self) -> float:
        return float(self.START_YEAR)


@dataclass
class Payer(BaseRecord):
    """Payer model corresponding to payers.csv"""
    Id: str
    NAME: str
    ADDRESS: Optional[str]
    CITY: Optional[str]
    STATE_HEADQUARTERED: Optional[str]
    ZIP: Optional[str]
    PHONE: Optional[str]
    AMOUNT_COVERED: float
    AMOUNT_UNCOVERED: float
    REVENUE: float
    COVERED_ENCOUNTERS: int
    UNCOVERED_ENCOUNTERS: int
    COVERED_MEDICATIONS: int
    UNCOVERED_MEDICATIONS: int
    COVERED_PROCEDURES: int
    UNCOVERED_PROCEDURES: int
    COVERED_IMMUNIZATIONS: int
    UNCOVERED_IMMUNIZATIONS: int
    UNIQUE_CUSTOMERS: int
    QOLS_AVG: float
    MEMBER_MONTHS: int
    
    @property
    def record_id(self) -> str:
        return self.Id
    
    @property
    def timestamp(self) -> float:
        return 0.0  # Placeholder


@dataclass
class Procedure(BaseRecord):
    """Procedure model corresponding to procedures.csv"""
    DATE: str
    PATIENT: str
    ENCOUNTER: str
    CODE: str
    DESCRIPTION: str
    BASE_COST: float
    REASONCODE: Optional[str]
    REASONDESCRIPTION: Optional[str]
    
    @property
    def record_id(self) -> str:
        return f"{self.PATIENT}_{self.CODE}_{self.DATE}"
    
    @property
    def timestamp(self) -> float:
        return 0.0  # Placeholder - would need proper date parsing


@dataclass
class Provider(BaseRecord):
    """Provider model corresponding to providers.csv"""
    Id: str
    ORGANIZATION: str
    NAME: str
    GENDER: str
    SPECIALITY: str
    ADDRESS: str
    CITY: str
    STATE: str
    ZIP: str
    LAT: float
    LON: float
    UTILIZATION: int
    
    @property
    def record_id(self) -> str:
        return self.Id
    
    @property
    def timestamp(self) -> float:
        return 0.0  # Placeholder


# Export all models
__all__ = [
    'Allergy',
    'CarePlan', 
    'Condition',
    'Encounter',
    'ImagingStudy',
    'Immunization',
    'Medication',
    'Observation',
    'Organization',
    'Patient',
    'PayerTransition',
    'Payer',
    'Procedure',
    'Provider'
]